use super::Vm;
use crate::cloud_hypervisor::{Disk, InitDisk};
use crate::network::utils::uuid_to_mac;

use unindent::unindent;

// Templating engine
use convert_case::{Case, Casing};

// Mac
use macaddr::MacAddr6;
use serde::{Deserialize, Serialize};
use std::str::FromStr;
use uuid::Uuid;

use std::path::Path;

// Global
use crate::config::MANAGED_DIR;

// "mkdir -p ./scripts/mnt/pipelight-init",
// "mount -t ext4 -o loop ./scripts/pipelight-init.img ./scripts/mnt/pipelight-init",
// "cp -r /pipelight-init/.* ./scripts/mnt/pipelight-init",
// "cp -r /pipelight-init/* ./scripts/mnt/pipelight-init",
// "umount ./scripts/mnt/pipelight-init",

use pipelight_exec::{Process, Status};
use std::fs;

// Error handling
use log::{debug, info};
use miette::{IntoDiagnostic, Result};
use virshle_error::{LibError, VirshleError};

#[derive(Default, Debug, Serialize, Deserialize, Clone, Eq, PartialEq)]
pub struct InitData {
    // Autogenerated data.
    pub vm: Option<VmData>,
    // User defined data.
    pub user: Option<UserData>,
}
#[derive(Default, Debug, Serialize, Deserialize, Clone, Eq, PartialEq)]
pub struct UserData {
    pub ipv6: Option<String>,
    pub ssh: Option<Vec<SshData>>,
}

#[derive(Default, Debug, Serialize, Deserialize, Clone, Eq, PartialEq)]
pub struct SshData {
    pub user: String,
    pub authorized_keys: Vec<String>,
}

/*
* Autogenerated data.
*/
#[derive(Debug, Serialize, Deserialize, Clone, Eq, PartialEq)]
pub struct VmData {
    mac: String,
    hostname: String,
}
impl From<&Vm> for VmData {
    fn from(e: &Vm) -> Self {
        Self {
            mac: uuid_to_mac(&e.uuid).to_string(),
            hostname: e.name.to_owned(),
        }
    }
}
impl From<&mut Vm> for VmData {
    fn from(e: &mut Vm) -> Self {
        Self {
            mac: uuid_to_mac(&e.uuid).to_string(),
            hostname: e.name.to_owned(),
        }
    }
}

impl InitData {
    /*
     * Convert user-data into a pipelight configuration file.
     */
    pub fn to_pipelight_toml_config(&self) -> Result<String, VirshleError> {
        let mut p_config = unindent(&format!(
            r#"
        [[pipelines]]
        name = "init"
        "#
        ))
        .to_owned();

        if let Some(vm) = &self.vm {
            // Add hostname
            let hostname = format!("vm-{}", vm.hostname);
            p_config += &unindent(&format!(
                r#"
            [[pipelines.steps]]
            name = "set hostname"
            commands = [
                "sysctl -w kernel.hostname='{hostname}'"
            ]
            "#
            ));
        }

        if let Some(user) = &self.user {
            // Add public ipv6
            if let Some(ipv6) = &user.ipv6 {
                let interface = "ens3";
                p_config += &unindent(&format!(
                    r#"
                [[pipelines.steps]]
                name = "set fixed mac address"
                commands = [
                    "source ./init.env && ip a $IPV6 add dev {interface}"
                ]
                "#,
                ));
            }

            // Add ssh authorized_keys
            if let Some(ssh) = &user.ssh {
                for data in ssh {
                    let username = &data.user;

                    let keys = data.authorized_keys.to_owned();
                    let mut commands = vec![];
                    // Add keys
                    for key in keys {
                        commands.push(unindent(&format!(
                            r#""echo \"{key}\n\" >> /etc/ssh/authorized_keys.d/{username}","#
                        )));
                    }
                    let commands = commands.join(",\n");

                    p_config += &unindent(&format!(
                        r#"
                    [[pipelines.steps]]
                    name = "set ipv6"
                    commands = [
                        "mkdir -p /etc/ssh/authorized_keys.d",
                        "touch /etc/ssh/authorized_keys.d/{username}",
                        "> /etc/ssh/authorized_keys.d/{username}",
                        {commands}
                    ]
                    "#
                    ));
                }
            }
        }
        Ok(p_config)
    }
}

impl Vm {
    /*
     * Create and provision an init disk,
     * and add it vm config.
     */
    pub fn add_init_disk(&mut self, user_data: Option<UserData>) -> Result<&Self, VirshleError> {
        // Make disk
        let init_disk = InitDisk { vm: &*self };

        let init_data = InitData {
            vm: Some(VmData::from(&*self)),
            user: user_data,
        };

        init_disk
            .create()?
            .mount()?
            .write_init_files(&init_data)?
            .umount()?;

        // Add to vm config
        let disk = Disk::from(&init_disk);
        self.disk.push(disk);

        debug!("Created an init disk for vm {}", self.uuid);
        Ok(self)
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_pipelight_config_render() -> Result<()> {
        let init_data = InitData {
            vm: Some(VmData {
                mac: uuid_to_mac(&Uuid::new_v4()).to_string().to_owned(),
                hostname: "izuku_midoryia".to_owned(),
            }),
            user: Some(UserData {
                ssh: Some(vec![SshData {
                    user: "anon".to_owned(),
                    authorized_keys: vec!["ssh-ed25519 AAAAD3N".to_owned()],
                }]),
                ..Default::default()
            }),
        };
        let res = init_data.to_pipelight_toml_config()?;
        println!("{}", res);
        Ok(())
    }
    // #[tokio::test]
    async fn test_init_disk_creation() -> Result<()> {
        // let vm = Vm::default();
        let vms = Vm::get_all().await?;
        let mut vm = vms.first().unwrap().to_owned();
        // println!("{:#?}", &vm);

        vm.add_init_disk(None)?;
        Ok(())
    }
}
