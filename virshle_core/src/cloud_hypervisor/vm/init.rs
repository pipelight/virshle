pub use super::account::Account;
use super::Vm;
use crate::cloud_hypervisor::{Disk, InitDisk};
use crate::network::utils::uuid_to_mac;

use unindent::unindent;

// Templating engine
use convert_case::{Case, Casing};

// Mac
use macaddr::MacAddr6;
use serde::{Deserialize, Serialize};
use std::net::IpAddr;
use std::str::FromStr;
use uuid::Uuid;

use std::path::Path;

// Global
use crate::config::MANAGED_DIR;

// "mkdir -p ./scripts/mnt/pipelight-init",
// "mount -t ext4 -o loop ./scripts/pipelight-init.img ./scripts/mnt/pipelight-init",
// "cp -r /pipelight-init/.* ./scripts/mnt/pipelight-init",
// "cp -r /pipelight-init/* ./scripts/mnt/pipelight-init",
// "umount ./scripts/mnt/pipelight-init",

use pipelight_exec::{Process, Status};
use std::fs;

// Error handling
use miette::{IntoDiagnostic, Result};
use tracing::{debug, info};
use virshle_error::{LibError, VirshleError};

#[derive(Default, Debug, Serialize, Deserialize, Clone, Eq, PartialEq)]
pub struct InitData {
    // Autogenerated data.
    pub vm_data: Option<VmData>,
    // User defined data.
    pub user_data: Option<UserData>,
}
#[derive(Default, Debug, Serialize, Deserialize, Clone, Eq, PartialEq)]
pub struct UserData {
    pub user: Vec<User>,
    /// Only purpose is to remain in database for further VM identification.
    pub account: Option<Account>,
}
#[derive(Default, Debug, Serialize, Deserialize, Clone, Eq, PartialEq)]
pub struct User {
    pub name: String,
    pub ssh: Option<SshParams>,
}
#[derive(Default, Debug, Serialize, Deserialize, Clone, Eq, PartialEq)]
pub struct SshParams {
    pub authorized_keys: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize, Clone, Eq, PartialEq)]
pub struct Ip {
    pub ipv6: IpAddr,
}

/// Autogenerated data:
/// - mac or mac_address is based on VM uuid.
/// - hostname is the VM name generated on VM creation.
#[derive(Debug, Serialize, Deserialize, Clone, Eq, PartialEq)]
pub struct VmData {
    mac: String,
    hostname: String,
}
impl From<&Vm> for VmData {
    fn from(e: &Vm) -> Self {
        Self {
            mac: uuid_to_mac(&e.uuid).to_string(),
            hostname: e.name.to_owned(),
        }
    }
}
impl From<&mut Vm> for VmData {
    fn from(e: &mut Vm) -> Self {
        Self {
            mac: uuid_to_mac(&e.uuid).to_string(),
            hostname: e.name.to_owned(),
        }
    }
}

impl InitData {
    /// Convert user-data into a pipelight configuration file.
    pub fn to_pipelight_toml_config(&self) -> Result<String, VirshleError> {
        // Run before network is up
        let mut p_config = "".to_owned();

        p_config += &unindent(&format!(
            r#"
        [[pipelines]]
        name = "init_net_pre"
        "#
        ))
        .to_owned();

        if let Some(vm_data) = &self.vm_data {
            // Add hostname
            let hostname = vm_data.hostname.clone();
            p_config += &unindent(&format!(
                r#"
            [[pipelines.steps]]
            name = "set hostname"
            commands = [
                "sysctl -w kernel.hostname='{hostname}'",
            ]
            "#
            ));
        }

        if let Some(user_data) = &self.user_data {
            for user in &user_data.user {
                if let Some(ssh) = &user.ssh {
                    let username = user.name.clone();
                    let keys = ssh.authorized_keys.to_owned();
                    let mut commands = vec![];
                    // Add keys
                    for key in keys {
                        commands.push(unindent(&format!(
                            r#""echo \"{key}\n\" >> /etc/ssh/authorized_keys.d/{username}","#
                        )));
                    }
                    let commands = commands.join(",\n");

                    p_config += &unindent(&format!(
                        r#"
                    [[pipelines.steps]]
                    name = "set ipv6 for user {username}"
                    commands = [
                        "mkdir -p /etc/ssh/authorized_keys.d",
                        "touch /etc/ssh/authorized_keys.d/{username}",
                        "> /etc/ssh/authorized_keys.d/{username}",
                        {commands}
                    ]
                    "#
                    ));
                }
            }
        }
        // Run after network is up
        p_config += &unindent(&format!(
            r#"
        [[pipelines]]
        name = "init_net_post"
        "#
        ));
        p_config += &unindent(&format!(
            r#"
            [[pipelines.steps]]
            name = "hard set network interface"
            commands = [
                "sysctl -w net.ipv6.conf.ens4.accept_ra=1"
            ]
            "#
        ));

        Ok(p_config)
    }
}

impl Vm {
    /// Create and provision an init disk,
    /// and add it vm config.
    #[tracing::instrument]
    pub fn add_init_disk(&mut self, user_data: Option<UserData>) -> Result<&Self, VirshleError> {
        debug!("Creating an init disk for vm {}", self.uuid);

        // Make disk
        let init_disk = InitDisk { vm: &*self };
        let init_data = InitData {
            vm_data: Some(VmData::from(&*self)),
            user_data,
        };
        init_disk
            .create()?
            .mount()?
            .write_init_files(&init_data)?
            .umount()?;

        // Add to vm config
        let disk = Disk::from(&init_disk);
        self.disk.push(disk);

        Ok(self)
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_pipelight_config_render() -> Result<()> {
        let init_data = InitData {
            vm_data: Some(VmData {
                mac: uuid_to_mac(&Uuid::new_v4()).to_string().to_owned(),
                hostname: "izuku_midoryia".to_owned(),
            }),
            user_data: Some(UserData {
                user: vec![User {
                    name: "anon".to_owned(),
                    ssh: Some(SshParams {
                        authorized_keys: vec!["ssh-ed25519 AAAAD3N".to_owned()],
                    }),
                }],
                ..Default::default()
            }),
        };
        let res = init_data.to_pipelight_toml_config()?;
        println!("{}", res);
        Ok(())
    }
    // #[tokio::test]
    async fn test_init_disk_creation() -> Result<()> {
        // let vm = Vm::default();
        let vms = Vm::get_all().await?;
        let mut vm = vms.first().unwrap().to_owned();
        // println!("{:#?}", &vm);

        vm.add_init_disk(None)?;
        Ok(())
    }
}
