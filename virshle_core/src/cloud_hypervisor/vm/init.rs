pub use super::account::{Account, AccountUser};
use super::Vm;
use crate::cloud_hypervisor::{Disk, InitDisk};
use crate::network::utils::uuid_to_mac;

use unindent::unindent;

// Templating engine
use convert_case::{Case, Casing};

// Mac
use macaddr::MacAddr6;
use serde::{Deserialize, Serialize};
use std::net::IpAddr;
use std::str::FromStr;
use uuid::Uuid;

use std::path::Path;

// Global
use crate::config::MANAGED_DIR;

// "mkdir -p ./scripts/mnt/pipelight-init",
// "mount -t ext4 -o loop ./scripts/pipelight-init.img ./scripts/mnt/pipelight-init",
// "cp -r /pipelight-init/.* ./scripts/mnt/pipelight-init",
// "cp -r /pipelight-init/* ./scripts/mnt/pipelight-init",
// "umount ./scripts/mnt/pipelight-init",

use pipelight_exec::{Process, Status};
use std::fs;

// Error handling
use log::{debug, info};
use miette::{IntoDiagnostic, Result};
use virshle_error::{LibError, VirshleError};

#[derive(Default, Debug, Serialize, Deserialize, Clone, Eq, PartialEq)]
pub struct InitData {
    // Autogenerated data.
    pub vm_data: Option<VmData>,
    // User defined data.
    pub user_data: Option<UserData>,
}
#[derive(Default, Debug, Serialize, Deserialize, Clone, Eq, PartialEq)]
pub struct UserData {
    pub account: Option<Account>,
    pub ssh: Option<Ssh>,
    pub network: Option<Ip>,
}
#[derive(Default, Debug, Serialize, Deserialize, Clone, Eq, PartialEq)]
pub struct Ssh {
    pub user: Vec<SshUser>,
}
#[derive(Default, Debug, Serialize, Deserialize, Clone, Eq, PartialEq)]
pub struct SshUser {
    pub name: String,
    pub authorized_keys: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize, Clone, Eq, PartialEq)]
pub struct Ip {
    pub ipv6: IpAddr,
}

/*
* Autogenerated data.
*/
#[derive(Debug, Serialize, Deserialize, Clone, Eq, PartialEq)]
pub struct VmData {
    mac: String,
    hostname: String,
}
impl From<&Vm> for VmData {
    fn from(e: &Vm) -> Self {
        Self {
            mac: uuid_to_mac(&e.uuid).to_string(),
            hostname: e.name.to_owned(),
        }
    }
}
impl From<&mut Vm> for VmData {
    fn from(e: &mut Vm) -> Self {
        Self {
            mac: uuid_to_mac(&e.uuid).to_string(),
            hostname: e.name.to_owned(),
        }
    }
}

impl InitData {
    /*
     * Convert user-data into a pipelight configuration file.
     */
    pub fn to_pipelight_toml_config(&self) -> Result<String, VirshleError> {
        // Run before network is up
        let mut p_config = "".to_owned();

        p_config += &unindent(&format!(
            r#"
        [[pipelines]]
        name = "init_pre"
        "#
        ))
        .to_owned();

        if let Some(vm_data) = &self.vm_data {
            // Add hostname
            let hostname = format!("vm-{}", vm_data.hostname);
            p_config += &unindent(&format!(
                r#"
            [[pipelines.steps]]
            name = "set hostname"
            commands = [
                "sysctl -w kernel.hostname='{hostname}'",
            ]
            "#
            ));
        }

        if let Some(user_data) = &self.user_data {
            // Add public ip(v6/v4)
            if let Some(network) = &user_data.network {
                let iface = "ens4";
                p_config += &unindent(&format!(
                    r#"
                [[pipelines.steps]]
                name = "set fixed mac address"
                commands = [
                    "ip a {} add dev {}"
                ]
                "#,
                    network.ipv6, iface,
                ));
            }

            // Add ssh authorized_keys
            if let Some(account) = &user_data.account {
                if let Some(user) = &account.user {
                    let username = user.name.clone();
                    let key = user.public_key.clone();
                    p_config += &unindent(&format!(
                        r#"
                    [[pipelines.steps]]
                    name = "set ipv6"
                    commands = [
                        "mkdir -p /etc/ssh/authorized_keys.d",
                        "touch /etc/ssh/authorized_keys.d/{username}",
                        "> /etc/ssh/authorized_keys.d/{username}",
                        "echo \"{key}\n\" >> /etc/ssh/authorized_keys.d/{username}"
                    ]
                    "#
                    ));
                }
            } else if let Some(ssh) = &user_data.ssh {
                for user in &ssh.user {
                    let username = user.name.clone();
                    let keys = user.authorized_keys.to_owned();
                    let mut commands = vec![];
                    // Add keys
                    for key in keys {
                        commands.push(unindent(&format!(
                            r#""echo \"{key}\n\" >> /etc/ssh/authorized_keys.d/{username}","#
                        )));
                    }
                    let commands = commands.join(",\n");

                    p_config += &unindent(&format!(
                        r#"
                    [[pipelines.steps]]
                    name = "set ipv6"
                    commands = [
                        "mkdir -p /etc/ssh/authorized_keys.d",
                        "touch /etc/ssh/authorized_keys.d/{username}",
                        "> /etc/ssh/authorized_keys.d/{username}",
                        {commands}
                    ]
                    "#
                    ));
                }
            }
        }
        // Run after network is up
        p_config += &unindent(&format!(
            r#"
        [[pipelines]]
        name = "init_post"
        "#
        ));
        p_config += &unindent(&format!(
            r#"
            [[pipelines.steps]]
            name = "hard set network interface"
            commands = [
                "sysctl -w net.ipv6.conf.ens4.accept_ra=1"
            ]
            "#
        ));

        Ok(p_config)
    }
}

impl Vm {
    /*
     * Create and provision an init disk,
     * and add it vm config.
     */
    pub fn add_init_disk(&mut self, user_data: Option<UserData>) -> Result<&Self, VirshleError> {
        // Make disk
        let init_disk = InitDisk { vm: &*self };

        let init_data = InitData {
            vm_data: Some(VmData::from(&*self)),
            user_data,
        };

        init_disk
            .create()?
            .mount()?
            .write_init_files(&init_data)?
            .umount()?;

        // Add to vm config
        let disk = Disk::from(&init_disk);
        self.disk.push(disk);

        debug!("Created an init disk for vm {}", self.uuid);
        Ok(self)
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_pipelight_config_render() -> Result<()> {
        let init_data = InitData {
            vm_data: Some(VmData {
                mac: uuid_to_mac(&Uuid::new_v4()).to_string().to_owned(),
                hostname: "izuku_midoryia".to_owned(),
            }),
            user_data: Some(UserData {
                ssh: Some(Ssh {
                    user: vec![SshUser {
                        name: "anon".to_owned(),
                        authorized_keys: vec!["ssh-ed25519 AAAAD3N".to_owned()],
                    }],
                }),
                ..Default::default()
            }),
        };
        let res = init_data.to_pipelight_toml_config()?;
        println!("{}", res);
        Ok(())
    }
    // #[tokio::test]
    async fn test_init_disk_creation() -> Result<()> {
        // let vm = Vm::default();
        let vms = Vm::get_all().await?;
        let mut vm = vms.first().unwrap().to_owned();
        // println!("{:#?}", &vm);

        vm.add_init_disk(None)?;
        Ok(())
    }
}
